# *************************************
# Created by: Kukpyo (Andrew) Han  - kha107@sfu.ca
# Created on: April 1, 2022
# Last Updated on: April 8, 2022
# Objective: This python code is intended to load parquet files containing predicted skills for respective job titles
#            (which are generated by "job_skill_model/job_skill_extraction_model_prediction.py")
#            and push all the records to MongoDB.
# Input files (before processing): located under "/job_skill_model/job_skill_prediction"
# Input files (after processing): located under "/job_skill_model/job_skill_prediction/archive"
# Output files : None
# *************************************


from mongodb_connector import connect_to_collection
import pandas as pd
import numpy as np
import glob
import os
import re
from datetime import datetime


def dict_constructor(text, job_title, prediction_prob, predicted_skill):
    output_dict = {
        'text': text,
        'job_title': job_title,
        'prediction_prob': prediction_prob,
        'predicted_skill': predicted_skill
    }

    return output_dict


if __name__ == "__main__":

    INPUT_PATH = r'job_skill_model/job_skill_prediction/'
    all_files = glob.glob(INPUT_PATH + "*.parquet")
    TIMESTAMP = datetime.today().strftime("%Y%m%d%H")

    # Adjust this flag to keep or remove the existing records on "JobSkills" collection
    INITIALIZE_FLAG = True

    # li is used to hold dataframes taken from the integrated_parquet folder.
    li = []

    print('============================== Read in the parquet files ===================================')

    for filename in all_files:
        df = pd.read_parquet(filename, columns=None)
        li.append(df)

    print('============================== Read in the parquet files (completed) ===================================')

    print('============================== Construct a dictionary for batch insert ===================================')
    # docs_to_insert will hold all the records to be inserted into "JobPosts" collection
    docs_to_insert = []
    for idx_df, df in enumerate(li):
        for idx_row, row in df.iterrows():
            jobskills_dict = dict_constructor(row['text'], row['job_title'], row['prediction_prob'],
                                              row['predicted_skill']
                                             )
            docs_to_insert.append(jobskills_dict)
    print('============================== Construct a dictionary for batch insert (completed) ==================='
          '================')

    print('============================== Connecting to MongoDB ===================================')
    # Connect to MongoDB and obtain "JobPosts" collection
    jobskills_collect = connect_to_collection("JobSkills")
    print('============================== Connecting to MongoDB (completed) ===================================')

    if INITIALIZE_FLAG:
        print('============================== Initialize Jobskills collection ===================================')
        jobskills_collect.delete_many({})
        print('============================== Initialize Jobskills collection (completed) ======================'
              '=============')

    print('============================== Inserting into MongoDB ===================================')
    result = jobskills_collect.insert_many(docs_to_insert)
    print("Number of documents added: ", len(result.inserted_ids))
    #print("New documents added: ", result.inserted_ids)
    print('============================== Inserting into MongoDB (completed) ===================================')

    print('============================== Move the processed files to archive ===================================')

    # Move the processed parquet files to archive folder.
    for filename in all_files:
        # Extract the file name from the full path.
        filename_tmp1 = filename.split("\\")
        # Source file path
        source = filename
        # destination file path
        dest = INPUT_PATH + "archive/" + filename_tmp1[1]

        try:
            os.rename(source, dest)
            print(f"{filename_tmp1[1]} : Source path renamed to destination path successfully.")
        # For permission related errors
        except PermissionError:
            print("Operation not permitted.")
        # For other errors
        except OSError as error:
            print(error)

    print('============================== Move the processed files to archive (completed) ====================='
          '=============')